---
title: "Packaging"
layout: single
tags: [CMake, Tutorial]
toc: true
excerpt: How to package and distribute CMake Projects with cpack
---
 
Learn how to distribute your libraries as CMake packages for easy integration into client's CMake projects.

# Imported Targets
Imagine a client of your library `foo` wants to integrate the library into his own CMake project. 
It would be nice if he could use the same build targets that you are using when building `foo` (for example to link against it via `target_link_libraries()`)
CMake allows for the definition of `IMPORTED` targets:

{% highlight cmake linenos %}
# Create imported target MyProject::foo
add_library(MyProject::foo SHARED IMPORTED)
{% endhighlight %}

Here, the library target `foo` (which resides in a namespace `MyProject::` - more on that later) is defined, but it is imported, which means that the actual library is being built in some other project. 
We are just making it known to the client's project at this point.

How nice would it be, if the actual library `foo` already came with these kinds of definitions and a client would not need to deal with the internals of some other project's build environment? 
This can be achieved by exposing the library's/project's interface, delivered as a CMake package, which will be described in the following sections.

# Export Sets
The first thing we have to do is to define an "Export Set" that will contain all the CMake targets that we want to export. 
We're installing an `EXPORT` via the `install()` command that we've seen in the [previous post](https://www.markusrothe.dev/Installing/) already.

{% highlight cmake linenos %}
install(EXPORT MyProjectTargets
    FILE MyProjectTargets.cmake
    NAMESPACE MyProject::
    DESTINATION lib/cmake/MyProject
)
{% endhighlight %}

First, we define the export set's name `MyProjectTargets`, followed by a file that will be generated by CMake `MyProjectTargets.cmake`.
We're then specifying that every target shall reside in a namespace called `MyProject::`. This makes it easier to see which project a target came from within the client's build.
Last, we want all the CMake package relevant files to be stored in `lib/cmake/MyProject` which is a common convention for distributing CMake package config files.

Now that we have defined the export set, we have to tell CMake which targets shall be part of that export set.
This is again done via the `install()` command and is done per target to export.
Here is an example of the library `foo`:

{% highlight cmake linenos %}
add_library(foo SHARED
    include/foo.h
    src/foo.cpp
)

target_include_directories(foo
    PUBLIC    
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include> 
        $<INSTALL_INTERFACE:include>
)

set_target_properties(foo
    PROPERTIES
    POSITION_INDEPENDENT_CODE 1
    COMPILE_DEFINITIONS BUILD_FOO
)

install(TARGETS foo EXPORT MyProjectTargets
    RUNTIME DESTINATION bin
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
)
install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/include 
    DESTINATION "."
)
{% endhighlight %}

After defining the library target and modifying some target properties, we're installing the target `foo` and we specify where to install the artifacts of the target.
Library and archive files will be placed in the `lib` folder, binaries (and Dll's on Windows) will be put into `bin` and the public headers of the lib go into `include`.
Finally, we are also installing the public headers as we want to distribute those for the lib, too.

Now, in the top-level `CMakeLists.txt` of our projet, we have to include cpack:

{% highlight cmake linenos %}
set(CPACK_GENERATOR "ZIP")
include(cpack)
{% endhighlight %}
We want the library to be packaged as a zip-file, so we're specifying the `CPACK_GENERATOR`. There are many more different generators for the different archivers as well as custom installers that can be created with cpack, but for this example, the zip is sufficient.
Then, we `include(cpack)` which will internally define a new `PACKAGE` CMake target that can be built individually like this:

{% highlight cmake linenos %}
cmake --build . --target package
{% endhighlight %}

Building the package target will create the zip-file inside the project's build directory.
In our case, the package's structure will look like this:

{% highlight ascii linenos %}
MyProject-1.2.3-win32.zip
├── bin/
│   └── foo.dll
├── include/
│   └── foo.h
└── lib/
    ├── cmake/
    │   └── MyProject/
    │       ├── MyProjectTargets.cmake
    │       └── MyProjectTargets-debug.cmake
    └── foo.lib
{% endhighlight %}

CMake will have created a `MyProjectTargets.cmake` file inside `lib/cmake/MyProject`. 
This is part of the content of the generated file:

{% highlight cmake linenos %}
...
add_library(MyProject::foo SHARED IMPORTED)

set_target_properties(MyProject::foo PROPERTIES
  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include"
)
...
{% endhighlight %}

And this is exactly what we wanted in the first place. 
We're now shipping a CMake config along with the library that specifies how the library target is to be used.
Note that we're also getting the library's include path via the target property `INTERFACE_INCLUDE_DIRECTORIES`.
This allows the client's CMake project to set the proper include path to find `foo`'s header files when linking agains foo via `target_link_libraries()`.

# Importing a package
Once we've created our package and it contains the CMake configuration files that expose our project's CMake build targets, a client can easily import the package via a call to `find_package()`:
{% highlight cmake linenos %}
...
find_package(MyProject VERSION 1.2.3 REQUIRED)
...
{% endhighlight %}

Here, we're specifying that we want to make use of the package `MyProject` in the version `1.2.3` and that our project requires the package to be present.
By default, CMake searches for the package within the `CMAKE_MODULE_PATH`, but there is a way to specify the path it should look into. 
Take a look at [`find_package()`'s documentation](https://cmake.org/cmake/help/latest/command/find_package.html?highlight=i) for details. 
(`find_package()` is a quite complex command which could warrant a full post).

Once the package has been found, a client can make use of the `MyProject::foo` target as if it was built inside his own CMake project:

{% highlight cmake linenos %}
target_link_libraries(myBin
    PRIVATE
    MyProject::foo
)
{% endhighlight %}

And as mentioned, CMake will take care of everything else (include paths, usage requirements etc.).

# Alias Library Targets
You've seen that a client can make use of the namespace `MyProject::` that was set for the export set above.
It is considered to be good practice to do the same inside `MyProject`'s own build tree as well. 
For that, CMake allows to define so called "alias targets", which are no real CMake targets. 
They only refer to other existing targets.
In the following code, the library `foo` is defined and directly afterwards, `MyProject::foo` is defined as an alias for `foo`.

{% highlight cmake linenos %}
add_library(foo SHARED
    include/foo.h
    src/foo.cpp
)
add_library(MyProject::foo ALIAS foo)
{% endhighlight %}

# Versioning
Imagine you are distributing different versions of your package. 
In that case, you want to provide the version information of your package along with the package.
CMake provides utility function to help you do that.
Here is an example of a top-level `CMakeLists.txt` file:

{% highlight cmake linenos %}
cmake_minimum_required(VERSION 3.10)
project(MyProject VERSION 1.2.3)

set(CMAKE_INSTALL_PREFIX ${CMAKE_BINARY_DIR}/install CACHE PATH "" FORCE)

add_subdirectory(foo)
add_subdirectory(bar)

include(CMakePackageConfigHelpers)
write_basic_package_version_file("MyProjectConfigVersion.cmake"
    VERSION ${MyProject_VERSION}
    COMPATIBILITY SameMajorVersion
)

install(FILES 
    "${CMAKE_CURRENT_SOURCE_DIR}/MyProjectConfig.cmake" 
    "${CMAKE_CURRENT_BINARY_DIR}/MyProjectConfigVersion.cmake"
    DESTINATION lib/cmake/MyProject
)

install(EXPORT MyProjectTargets
    FILE MyProjectTargets.cmake
    NAMESPACE MyProject::
    DESTINATION lib/cmake/MyProject
)

set(CPACK_GENERATOR "ZIP")
include(cpack)
{% endhighlight %}

In the `project` command we pass the version of the project.
After adding the subdirectories that contain the different library- and executable targets, we're including the CMake module `CMakePackageConfigHelpers` which contains the command `write_basic_package_version_file`. 
This command will generate a file (`MyProjectConfigVersion.cmake` in our case) which will contain the version information that we want to distribute in our package.
A call to `find_package()` by a client will search for that configuration file.

Next, we have to write another file ourselves: `MyProjectConfig.cmake`. We'll put this file right next to the top-level `CMakeLists.txt` and write it as follows:
{% highlight cmake linenos %}
include(CMakeFindDependencyMacro)
find_dependency(Bar 2.0)
include("${CMAKE_CURRENT_LIST_DIR}/MyProjectTargets.cmake")
{% endhighlight %}

In this file, we're including the module `CMakeFindDependencyMacro`, which contains the `find_dependency()` command. 
If the library `foo` was depending on another library `Bar` in version 2.0, we'd call `find_dependency(Bar 2.0)`. 
This makes sure that whoever uses `foo` gets informed that `foo` comes with a dependency to `Bar`.

After that we're including `MyProjectTargets.cmake`, which we have already seen above.

Now that we have both, the `MyProjectConfigVersion.cmake` and `MyProjectConfig.cmake` files, we have to install them as well:
{% highlight cmake linenos %}
install(FILES 
    "${CMAKE_CURRENT_SOURCE_DIR}/MyProjectConfig.cmake" 
    "${CMAKE_CURRENT_BINARY_DIR}/MyProjectConfigVersion.cmake"
    DESTINATION lib/cmake/MyProject
)
{% endhighlight %}
Note that the generated file (`MyProjectConfigVersion.cmake`) comes from `${CMAKE_CURRENT_BINARY_DIR}`, while our own hand-written config file (`MyProjectConfig.cmake`) comes from `${CMAKE_CURRENT_SOURCE_DIR}`. 
When creating the package, both files will also be inside `lib/cmake/MyProject`.



# Code & Resources
The code for this post can be found on Github via the following tag:
[Packaging](https://github.com/markusrothe/cmake_essentials/tree/Packaging)